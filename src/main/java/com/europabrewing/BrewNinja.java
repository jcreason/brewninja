/*
 * Copyright Â© 2013 Jarett Creason
 *
 * This file is part of BrewNinja.
 *
 * BrewNinja is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * BrewNinja is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with BrewNinja in the file named COPYING in the root directory.
 * If not, see <http://www.gnu.org/licenses/>.
 */

package com.europabrewing;

import com.europabrewing.daos.BurnerDAOHibernate;
import com.europabrewing.daos.PumpDAOHibernate;
import com.europabrewing.models.Burner;
import com.europabrewing.models.PinController;
import com.europabrewing.models.Pump;
import com.europabrewing.util.HibernateUtil;
import com.europabrewing.util.NullOutputStream;
import com.europabrewing.util.SysInfoUtil;
import com.google.common.base.Joiner;
import com.google.common.collect.Iterables;
import com.pi4j.io.gpio.GpioController;
import com.pi4j.io.gpio.GpioFactory;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.ToggleButton;
import javafx.scene.control.ToggleGroup;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.paint.CycleMethod;
import javafx.scene.paint.LinearGradient;
import javafx.scene.paint.Stop;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.hibernate.Session;

import java.io.PrintStream;
import java.util.List;

/**
 * @author jcreason - jcreason@gmail.com
 * @date June 2013
 *
 * Please see the README and/or documentation associated
 *
 *
 * #####  Color Palette by Color Scheme Designer
 * #####  Generated by Color Scheme Designer (c) Petr Stanicek 2002-2010
 * #####  Palette URL: http://colorschemedesigner.com/#2J11D8rZrclQR
 * #####  Color Space: RGB;
 *
 * ** Primary Color:
 *
 * var. 1 = #CAFDBA = rgb(202,253,186)
 * var. 2 = #BBE5AE = rgb(187,229,174)
 * var. 3 = #98DB82 = rgb(152,219,130)
 * var. 4 = #E1FFD8 = rgb(225,255,216)
 * var. 5 = #F2FFEE = rgb(242,255,238)
 */
public class BrewNinja extends Application {

	/**
	 * If The GPIO controller is null, means we're running in development mode
	 */
	public static final boolean DEV_MODE;

	private final static int INIT_WIDTH = 1280;

	private final static int INIT_HEIGHT = 800;

	private final static Logger logger = LogManager.getLogger(BrewNinja.class.getName());

	private static final GpioController gpioController;

	private static final Integer FONT_NORMAL = 18;

	private static final Integer FONT_BIG = 26;

	static {
		/*
		 * Create SINGLE GPIOController instance on initialization
		 * Do some shenanigans here redirect STDERR to NULL to stop the Pi4J
		 * library from printing an error directly to STDERR.  Changing the logging levels
		 * was not catching a stack trace when running this on non-RaspberryPi hardware,
		 * and that was annoying, so I capture that the brute force way.
		 * If you find this, and know a better solution, then by all means, implement it.
		 */
		GpioController tmpGpioCon = null;
		PrintStream origErrOut = System.err;
		try {
			System.setErr(new PrintStream(new NullOutputStream()));
			tmpGpioCon = GpioFactory.getInstance();
		} catch (UnsatisfiedLinkError e) {
			logger.warn("Looks like you might not be running on a Raspberry Pi architecture.  Running in DEV mode.");
		} finally {
			System.setErr(origErrOut);
		}
		gpioController = tmpGpioCon;

		// if the GPIO Controller is null after the fact, it couldn't be initialized,
		// meaning we're not running on a RaspPi, so set us up to be in "DEV_MODE"
		DEV_MODE = null == gpioController;
	}

	private List<Burner> burners;

	private List<Pump> pumps;

	/**
	 * Build the class the manages it all.
	 * On construction, all equipment is loaded in from the database
	 */
	public BrewNinja() {
		initializeEquipmunk();

		logger.trace("All burners configured:\n\t * " + Joiner.on("\n\t * ").join(burners));
		logger.trace("All pumps configured:\n\t * " + Joiner.on("\n\t * ").join(pumps));

		if (!DEV_MODE) {
			SysInfoUtil.logInfo();
		}
	}

	/**
	 * MAIN
	 *
	 * @param args command line arguments
	 */
	public static void main(String[] args) {
		// fire up the GUI and instantiate a BrewNinja object
		launch(args);
	}

	@Override
	public void start(Stage stage) throws Exception {
		stage.setTitle("BrewNinja");

		BorderPane border = new BorderPane();
		border.setTop(createHeader());
		border.setLeft(createLeftPane());
		border.setCenter(createCenter());
		border.setRight(createRightPane());

		Scene scene = new Scene(border, INIT_WIDTH, INIT_HEIGHT);

		stage.setScene(scene);
		stage.setFullScreen(true);
		stage.setResizable(false);
		stage.show();
	}

	/**
	 * Test all of the PinControllers by turning them on, then back off.
	 * Prints to STDOUT
	 *
	 * @throws InterruptedException
	 */
	public void testPinControllers() throws InterruptedException {
		if (DEV_MODE) {
			System.out.println("Running in DEV mode, not going to test pins we don't have...");
			return;
		}

		System.out.println("Turning on all burners");
		for (Burner burner : burners) {
			burner.turnOn();
			Thread.sleep(3000);
		}
		Thread.sleep(10000);

		System.out.println("Turning on all pumps");
		for (Pump pump : pumps) {
			pump.turnOn();
			Thread.sleep(3000);
		}
		Thread.sleep(10000);

		System.out.println("Turning off all burners");
		for (Burner burner : burners) {
			burner.turnOff();
			Thread.sleep(3000);
		}
		Thread.sleep(10000);

		System.out.println("Turning off all pumps");
		for (Pump pump : pumps) {
			pump.turnOff();
			Thread.sleep(3000);
		}
	}

	/**
	 * Shut everything down
	 */
	public void shutdown() {
		if (null != gpioController) {
			gpioController.shutdown();
		}
	}

	/**
	 * Create the center content which holds all of the main data
	 *
	 * @return
	 */
	private GridPane createCenter() {
		GridPane grid = new GridPane();
		grid.setAlignment(Pos.CENTER);
		grid.setHgap(10);
		grid.setVgap(10);
//		grid.setPadding(new Insets(25, 25, 25, 25));
//		grid.setGridLinesVisible(true);

		// burners
		for (int i = 0; i < burners.size(); i++) {
			Node burnerPane = createBurnerPane(burners.get(i));
			grid.add(burnerPane, i, 0);
		}

		// pumps
		HBox pumpBox = new HBox(20);
		pumpBox.setPadding(new Insets(10));
		pumpBox.setAlignment(Pos.CENTER_RIGHT);
		for (Pump pump : pumps) {
			Node pumpPane = createPumpPane(pump);
			pumpBox.getChildren().add(pumpPane);
		}
		grid.add(pumpBox, 0, 1, 3, 1);

		return grid;
	}

	/**
	 * Create a Node to represent manual control of a Pump
	 *
	 * @param pump
	 * @return
	 */
	private Node createPumpPane(final Pump pump) {
		// the rectangle
		StackPane stack = new StackPane();
		Rectangle pumpBox = new Rectangle(200.0, 100.0);
		pumpBox.setFill(new LinearGradient(0, 0, 0, 1, true, CycleMethod.NO_CYCLE,
										   new Stop(0, Color.web("#CAFDBA")),
										   new Stop(1, Color.web("#F2FFEE"))));
		pumpBox.setStroke(Color.web("#D0E6FA"));
		pumpBox.setArcHeight(3.5);
		pumpBox.setArcWidth(3.5);

		// box inside rectangle
		VBox innerVBox = new VBox(8);
		innerVBox.setPadding(new Insets(10));
		innerVBox.setAlignment(Pos.CENTER);

		Text pumpName = new Text(pump.getName());
		pumpName.setFont(Font.font("Helvetica", FontWeight.BOLD, FONT_BIG));
		innerVBox.getChildren().add(pumpName);

		// buttons
		final ToggleGroup group = new ToggleGroup();

		ToggleButton off = new ToggleButton("Off");
		off.setToggleGroup(group);
		off.setSelected(true);

		ToggleButton on = new ToggleButton("On");
		on.setToggleGroup(group);

		HBox hBox = new HBox(10);
		hBox.setPadding(new Insets(10));
		hBox.setAlignment(Pos.CENTER);
		hBox.getChildren().addAll(off, on);

		on.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				logger.info("Turning on pump " + pump);
				pump.turnOn();
			}
		});

		off.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				logger.info("Turning off pump " + pump);
				pump.turnOff();
			}
		});

		// combine and return
		innerVBox.getChildren().add(hBox);
		stack.getChildren().addAll(pumpBox, innerVBox);

		return stack;
	}

	/**
	 * Create the pane in the center to show the burner status
	 *
	 * @param burner
	 * @return
	 */
	private Node createBurnerPane(final Burner burner) {

		// the outer box with a couple on/off buttons
		VBox outerVBox = new VBox(8);
		outerVBox.setPadding(new Insets(10));
		outerVBox.setPrefWidth(300);

		// the rectangle
		StackPane stack = new StackPane();
		Rectangle burnerBox = new Rectangle(200.0, 230.0);
		burnerBox.setFill(new LinearGradient(0, 0, 0, 1, true, CycleMethod.NO_CYCLE,
											 new Stop(0, Color.web("#CAFDBA")),
											 new Stop(1, Color.web("#F2FFEE"))));
		burnerBox.setStroke(Color.web("#D0E6FA"));
		burnerBox.setArcHeight(3.5);
		burnerBox.setArcWidth(3.5);
		burnerBox.widthProperty().bind(stack.widthProperty());


		// box inside rectangle
		VBox innerVBox = new VBox(8);
		innerVBox.setPadding(new Insets(10));

		Text burnerName = new Text(burner.getName());
		burnerName.setFont(Font.font("Helvetica", FontWeight.BOLD, FONT_BIG));
		innerVBox.getChildren().add(burnerName);

		if (null != burner.getTempMonitor()) {
			Text currTemp = new Text("Current Temp: xx F");
			currTemp.setFont(Font.font("Helvetica", FontWeight.NORMAL, FONT_NORMAL));
			innerVBox.getChildren().add(currTemp);

			if (null != burner.getPump()) {
				Text targetTemp = new Text("Target Temp: xx F");
				targetTemp.setFont(Font.font("Helvetica", FontWeight.NORMAL, FONT_NORMAL));
				innerVBox.getChildren().add(targetTemp);
			}
		}

		innerVBox.setAlignment(Pos.TOP_CENTER);
		stack.getChildren().addAll(burnerBox, innerVBox);
		stack.setAlignment(Pos.CENTER);
		outerVBox.getChildren().add(stack);

		/* Below the rectangle now */

		outerVBox.getChildren().add(createBurnerOnOffHbox(burner));

		if (null != burner.getTempMonitor() && null != burner.getPump()) {
			outerVBox.getChildren().add(createAutomateBurnerHbox(burner));
		}

		return outerVBox;
	}

	/**
	 * Create the on/off for temp automation
	 *
	 * @param burner
	 * @return
	 */
	private HBox createAutomateBurnerHbox(final Burner burner) {
		HBox hBox = new HBox(10);
		hBox.setPadding(new Insets(10));

		Text text = new Text("Automate Temp:");
		text.setFont(Font.font("Helvetica", FontWeight.NORMAL, FONT_NORMAL));

		final ToggleGroup group = new ToggleGroup();

		ToggleButton off = new ToggleButton("Off");
		off.setToggleGroup(group);
		off.setSelected(true);

		ToggleButton on = new ToggleButton("On");
		on.setToggleGroup(group);
		hBox.getChildren().addAll(text, off, on);

		on.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				logger.info("Telling the burner " + burner + " to automate it's own temperature");
				burner.automateTemp(true);
			}
		});

		off.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				logger.info("Telling the burner " + burner + " to stop automating it's own temperature");
				burner.automateTemp(false);
			}
		});

		return hBox;
	}

	/**
	 * Create the burner on/off horizontal box Node
	 *
	 * @param burner
	 * @return
	 */
	private HBox createBurnerOnOffHbox(final Burner burner) {
		HBox hBox = new HBox(10);
		hBox.setPadding(new Insets(10));

		Text text = new Text("Burner:");
		text.setFont(Font.font("Helvetica", FontWeight.NORMAL, FONT_NORMAL));

		final ToggleGroup group = new ToggleGroup();

		ToggleButton off = new ToggleButton("Off");
		off.setToggleGroup(group);
		off.setSelected(true);

		ToggleButton on = new ToggleButton("On");
		on.setToggleGroup(group);
		hBox.getChildren().addAll(text, off, on);

		on.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				logger.info("Turning on burner " + burner);
				burner.turnOn();
			}
		});

		off.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				logger.info("Turning off burner " + burner);
				burner.turnOff();
			}
		});

		return hBox;
	}

	/**
	 * Creates the header region at the top of the window
	 *
	 * @return
	 */
	private HBox createHeader() {
		HBox hbox = new HBox(10);
		hbox.setPadding(new Insets(15, 12, 15, 12));
		hbox.setStyle("-fx-background-color: #CAFDBA;");

		Text title = new Text("BrewNinja");
		title.setFont(Font.font("Helvetica", FontWeight.BOLD, FONT_BIG));
		hbox.setAlignment(Pos.CENTER);

		hbox.getChildren().add(title);

		return hbox;
	}

	/**
	 * Creates the left pane of the window
	 *
	 * @return
	 */
	private VBox createLeftPane() {
		VBox vbox = new VBox(8);
		vbox.setPadding(new Insets(10));

		return vbox;
	}

	/**
	 * Creates the right pane of the window
	 *
	 * @return
	 */
	private VBox createRightPane() {
		VBox vbox = new VBox(8);
		vbox.setPadding(new Insets(10));

		return vbox;
	}

	/**
	 * Initialize all of the equipment including
	 * Burners & liquid Pumps
	 */
	private void initializeEquipmunk() {
		logger.trace("Retrieving all equipment from database");

		Session session = HibernateUtil.getSession();

		this.burners = new BurnerDAOHibernate(session).getEnabledBurners();
		this.pumps = new PumpDAOHibernate(session).getEnabledPumps();

		if (!DEV_MODE) {
			// both pumps and burners inherit from PinController, so combine and couple with
			// the pins outputs on the RaspberryPi board
			Iterable<PinController> pinControllers = Iterables.concat(burners, pumps);
			for (PinController pinController : pinControllers) {
				pinController.couplePin(gpioController);
			}
		}

		session.close();
	}
}
